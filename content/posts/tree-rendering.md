---
title: "Tree Rendering - TreeGen Part 2"
draft: false
date: 2024-09-06
weight: 1
showtoc: true
tags: ["Tree Rendering", "Ray Marching", "Curves", "Graphics", "OpenGL", "C++", "GLSL"]
cover:
    image: "/images/procedural-tree-generation/forest.gif"
description: "Rendering trees in real-time using ray marching"
summary: "Rendering trees in real-time using ray marching"
---

In this part, I will talk about how I rendered the trees generated in [the first part](/posts/procedural-tree-generation) inside TreeGen. I will discuss advantages and disadvantages of using ray marching, how I implemented it, and how I optimized it.

This part will assume you have basic knowledge of ray marching and SDFs, I will not explain those concepts since there are much better sources for that:

- [Inigo Quilez's articles](https://iquilezles.org/www/index.htm)
- [Jamie Wong's articles](http://jamie-wong.com/2016/07/15/ray-marching-signed-distance-functions/)

# Why use ray marching & curves?

Generally, trees are rendered as 3D meshes made up of triangles using rasterization, even if they were generated as truncated cones, a mesh is generated from combining those cones. Instead of using rasterization, TreeGen converts generated branches to quadratic Bézier curves and render them using ray marching, this has the advantage of dynamic manipulation of the tree shape in the shader, simpler mathematical representation and less messy code that is contained in the shader. The disadvantage is that ray marching is much slower than rasterization, this is why I had to optimize the ray marching code as much as possible.

I wanted to render the branches as smoot as possible, this is why I chose to use curves instead of truncated cones. The curves are generated by converting the branches to quadratic Bézier curves. Since real-time rendering was a main point of the project, I used quadratic Bézier curves instead of cubic Bézier curves since their mathematical representation is simpler and their SDF is much faster to calculate.

These bein said, the real reason I chose ray marching & curves is that this was a thesis project and I wanted to introduce non-traditional rendering techniques to the project. Also, ray marching is much easier to experiment with in my opinion.

# Quadratic Bézier curves

Bézier curves are parametric curves that are defined by 2 end points and control points, TreeGen uses quadratic Bézier curves to render branches. Although I will explain the mathematics, there are much more detailed sources explaining Bézier curves, I recommend watching [this video](https://www.youtube.com/watch?v=aVwxzDHniEw) by Freya Holmér.

Quadratic Bézier curves are defined by 3 points: the start point, the control point, and the end point. They are actually parabolas in 2D. The curve is calculated by the formula:

$B(t) = (1 - t)^2P_0 + 2(1 - t)tP_1 + t^2P_2$

or

$B(t) = (P_0 - 2P_1 + P_2)t^2 + (P_1 - P_0)2t + P_0$

Where $P_0$ is the start point, $P_1$ is the control point, and $P_2$ is the end point. $t$ is a value between 0 and 1 that represents the position on the curve.

The derivative of the curve is calculated by the formula:

$B'(t) = -2(1 - t)P_0 + 2(1 - 2t)P_1 + 2tP_2$

or

$B'(t) = 2(P_2 - 2P_1 + P_0)t + 2(P_1 - P_0)$

Substituting $A = P_1 - P_0$ and $B=P_2 - 2P_1 + P_0$:

$B(t) = Bt^2 + 2At + P_0$

$B'(t) = 2(Bt + A)$

To find the closest point on the curve to a given point, we need to find the minimum distance between the point and the curve. By definition, the closest point on the curve to a given point is the point where the tangent of the curve is perpendicular to the line between the point and the curve, so we need to solve the equation:

$B'(t).(P - B(t)) = 0$

Where $P$ is the given point and $.$ is the dot product. This can be rewritten as:

$(2(Bt + A)).(P - (Bt^2 + 2At + P_0)) = 0$

$(Bt + A).(P - Bt^2 - 2At - P_0) = 0$

Substitute $P' = P_0 - P$:

$(Bt + A).-(Bt^2 + 2At + P') = 0$

$B^2t^3+3ABt^2+(2A^2+BP')t+AP'=0$

$t^3+\frac{3ABt^2+(2A^2+BP')t+AP'}{B^2}=0$

This is a [cubic equation](https://en.wikipedia.org/wiki/Cubic_equation), which can be solved using various methods. I will not go into detail on how it is solved. There are 3 possible solutions at max and the closest point is the one that has the smallest distance to the given point.

## GLSL Code

Function for calculating distance & closest point on a quadratic Bézier curve from a given point:
```glsl
vec2 sdBezier(vec3 p, Bezier bezier)
{    
    vec3 A = bezier.start;
    vec3 B = bezier.mid;
    vec3 C = bezier.end;
    vec3 a = B - A;
    vec3 b = A - B * 2.0 + C;
    vec3 c = a * 2.0;
    vec3 d = A - p;
    
    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) / dot(b,b);     
    
    
    vec2 t = solveCubic(k.x, k.y, k.z);
    vec2 clampedT = clamp(t, 0.0, 1.0);

    vec3 pos = A + (c + b * clampedT.x) * clampedT.x;
    float tt = t.x;
    float dis = length(pos - p);
    pos = A + (c + b * clampedT.y) * clampedT.y;
    float dis2 = length(pos - p);
    bool y = dis2 < dis;
    dis = mix(dis, dis2, y);
    tt = mix(t.x, t.y, y);
    //pos = A + (c + b*t.z)*t.z;
    //dis = min(dis, length(pos - p));
    return vec2(dis, tt);
}
```

Notice that I do not return the clamped $t$ value, this is because I will use the $t$ value to check if the point is inside the curve or not.

Function for solving cubic equations:
```glsl
vec2 solveCubic(float a, float b, float c) {
	// Depress the cubic to solve it
    float p = b - a*a / 3.0, p3 = p*p*p;
    float q = a * (2.0*a*a - 9.0*b) / 27.0 + c;
    float d = q*q + 4.0*p3 / 27.0;
    float offset = -a / 3.0;
    // One real root
    if(d >= 0.0) { 
        // Cardano's method
        float z = sqrt(d);
        vec2 x = (vec2(z, -z) - q) / 2.0;
        vec2 uv = sign(x)*pow(abs(x), vec2(1.0/3.0));
        return vec2(offset + uv.x + uv.y);
    }
    // Three real roots
    // Trigonometric solution
    // x = 3q / 2p * sqrt(-3 / p)
    float x = -sqrt(-27.0 / p3) * q / 2.0;
    
    // This is an approximation for m=cos(acos(x)/3.0)
    x = sqrt(0.5+0.5*x);
    float m = x*(x*(x*(x*-0.008978+0.039075)-0.107071)+0.576974)+0.5;
    
    float n = sqrt(1.-m*m)*sqrt(3.);
    return vec2(m + m, -n - m) * sqrt(-p / 3.0) + offset;
}
```

Both of these are modified versions of functions from [Inigo Quilez's Quadratic Bezier - distance shader](https://www.shadertoy.com/view/ldj3Wh).

# Creating Curves from Branches

# Hybrid Rendering 

TreeGen uses a hybrid rendering technique, while the tree body is rendered using ray marching, other objects such as the leaves are rendered using rasterization. This is because ray marching is slower than rasterization and rasterization is more suitable for simple quads/meshes. I will explain the ray marching setup and how I matched the depth of both rendering techniques. 

## Ray Marching Setup

In most of the cases, ray marching is done on a full-screen quad, but in TreeGen the ray marching shader runs per bounding box of every branch. This is because I wanted to minimize missing rays and optimize the ray marching as much as possible. I used a simple axis aligned bounding box (AABB) for the curves, but it might be better to use a tighter bounding object for the curves such as cylinders. The bounding box calculation is done in the CPU using the functions in (Inigo Quilez's Bézier bounding box article)[https://iquilezles.org/articles/bezierbbox/] and passed to the [vertex shader](#vertex-shader). After the vertex shader transforms the bounding box and a pixel is rasterized, the fragment shader starts ray marching from the world space position of the pixel with direction:

```glsl
vec3 rayDir = normalize(worldPos - cameraDir);
```

At the beginning, I used a fixed minimum distance and step count since I was experimenting with the ray marching, but I later switched to adaptive step count and minimum distance based on camera-bounding box distance to optimize the ray marching to optimize the ray marching. If the curve is further away from the camera, then it does not need to be rendered with high detail, so the step count is lower and minimum distance is higher. This is especially useful while rendering shadows, where I exaggerated the minimum distance and step count.

## Matching Depth

The resulting position of ray marching is in world space, so we need to convert the depth to screen space and perspective divide. 

Firstly, we need some properties of the camera, the ray direction and hit depth from ray marching. I calculate the ray direction as the normalized vector from the camera position to a point on the transformed bounding box, which was rasterized.

```glsl
float hitDepth;
vec3 rayDir;
vec3 cameraDir;
float farPlane;
float nearPlane;
```

Convert the hit depth to eye space:

```glsl
float eyeHitZ = -hitDepth * dot(cameraDir, rayDir);
```

Convert the eye space depth to clip space:

```glsl
float clipZ = ((farPlane + nearPlane) / (farPlane - nearPlane)) * eyeHitZ + [2.0 * farPlane * nearPlane / (farPlane - nearPlane)];
float clipW = -eyeHitZ;
```

Perspective division, which will convert the clip space depth to normalized device coordinates (NDC):

```glsl
float ndcDepth = clipZ / clipW;
// This is the same, but in one line
float ndcDepth = ((farPlane + nearPlane) + (2.0 * farPlane * nearPlane) / eyeHitZ) / (farPlane - nearPlane);
```

To write it into the depth buffe, we will need to convert it to range $[0, 1]$. OpenGL exposes 3 variables for depth range: `gl_DepthRange.near`, `gl_DepthRange.far`, and `gl_DepthRange.diff`, which are respectively $0.0$, $1.0$ and $1.0$ unless specified otherwise with `glDepthRange(float nearVal, float farVal)`. Finally, we can calculate the value that will be written in the depth buffer as:

```glsl
float depthBufferVal = ((gl_DepthRange.diff * ndcDepth) + gl_DepthRange.near + gl_DepthRange.far) / 2.0;
```

By default, gl_FragDepth is not an output of the fragment shader, if a shader writes to it, then it must be specified explicitly:

```glsl
layout out float gl_FragDepth;
```

Writing the depth value to the depth buffer:

```glsl
gl_FragDepth = depthBufferVal;
```

Since I use a bounding box and start ray marching from its boundary, it is guranteed that calculated depth value will be bigger than the current depth value of the rasterized pixel, which was calculated from the bounding box. Because of this, I can mark the `gl_FragDepth` as `(depth_greater)` to *theoratically* enable early depth testing, which discards the fragment if the depth value is greater than the current depth value in the depth buffer, which was calculated previously from the result of another fragment shader. I say theoratically since I tested it in 3 differen setups and it did not enable early depth testing, so I am not sure if it works or not. There is `layout(early_fragment_tests) in;` which forces early depth testing, but it disables depth writes in the fragment shader, which should not be the case since `gl_FragDepth` is marked as `(depth_greater)`, and `discard` does not seem to work with it, so I cannot use it either.

# Tree Shader

## Data Structures

## Vertex Shader

## Static Fragment Shader

## Animated Fragment Shader

# Animating Growth

# Optimizations & Benchmarking

# Conclusion

